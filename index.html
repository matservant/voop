<!DOCTYPE html>

<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">  
	<title>Voop</title> 
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #FFFFFF;
      
    }    
  </style> 
</head>
<body>

  <!--<input type="range" min="0" max="5" value="5" oninput="setSpeed(value)" onchange="setSpeed(value)">-->

  <script src="recorder.js"></script>
  <script src="pixi.js"></script>

  <script>  

  var audio_context;
  var recorder;
  var samples = [];  
  var circles = [];  
  var speed = 5;  
  var gap = 15;
  var canRec = true;
  var isRec = false;
  var tints = [
    0xFF0000,
    0x00FF00,
    0xFF00FF,
    0x0000FF
  ];
  var mouse = {x: 0, y: 0};

document.addEventListener('mousemove', function(e){ 
    mouse.x = e.clientX || e.pageX; 
    mouse.y = e.clientY || e.pageY 
}, false);
  
  //right click event
  window.addEventListener('contextmenu', function(event) {
    event.preventDefault();
    
    for (var i=0; i < circles.length; i++) {
      var circle = circles[i];
      if(circle.isInside(event.x, event.y)) {
        console.log("duplicazzo!");

        var au = document.createElement('audio');      	      
	    au.controls = false;
    	au.src = samples[i].src;      	
      	samples.push(au);      
        
        var newCircle = createCircle(event.x, event.y, circle.tint);
        newCircle.isDuplicated = true;
        pushCircle(newCircle);
        break;
      }    
    }
    
    return false;
}, false);

  window.onmousedown = function(event) {   

          isRec = false;

          //check that is not dragging a circle
          for (var i=0; i < circles.length; i++) {
            var circle = circles[i];
            if(circle.isInside(event.x, event.y)) {              
              canRec = false;    
              console.log("inside my body");
            }
          }          

          if(canRec) {  
            //stop playback while recording
            for (var i=0; i < samples.length; i++) {    
              samples[i].pause();
              samples[i].currentTime = 0;
            }                
            isRec = true;    

            //200 is to avoid overlap of samples, as the stop is not immediate
            //setTimeout(function() {startRecording()}, 200);                          
            startRecording();                          
          }

          console.log("press");
  }

  window.onmouseup = function(event) {
    
          if (isRec) {
            console.log("isrec: " + isRec);
            stopRecording();
            var tint = tints[Math.floor(Math.random()*tints.length)];
            var circle = createCircle(event.x, event.y, tint);
            pushCircle(circle);
          }
          
          for(var i=0; i < circles.length; i++) {
            circles[i].isDuplicated = false;
          }
          
          canRec = true;
          isRec = false;
          console.log("release");          
  }


  var stage = new PIXI.Stage(0xFFFFFF);
  var renderer = PIXI.autoDetectRenderer(window.innerWidth, window.innerHeight, null);
  
  document.body.appendChild(renderer.view);

  requestAnimFrame( animate );

  var texture = PIXI.Texture.fromImage("dot.png");  

  var timelineTxt = PIXI.Texture.fromImage("timeline.png");
  var timelineTop = new PIXI.Sprite(timelineTxt);
  var timelineBot = new PIXI.Sprite(timelineTxt);
  
  timelineTop.position.x = 0;
  timelineTop.position.y = 30;

  timelineBot.position.x = 0;
  timelineBot.position.y = window.innerHeight - 30;
  
  stage.addChild(timelineTop);
  stage.addChild(timelineBot);

  function animate() {
      requestAnimFrame( animate );   

      timelineTop.x += speed;
      timelineBot.x += speed;

      if(timelineTop.x > renderer.width) {
        timelineTop.x = 0;
        timelineBot.x = 0;
      }

      for (var i=0; i < circles.length; i++) {
        var circle = circles[i];

        circle.scale.x += (circle.scaleDx - circle.scale.x) * 0.1;
        circle.scale.y += (circle.scaleDy - circle.scale.y) * 0.1;

        if(circle.scale.x > 1.4) {
          circle.deBounce();
        }
        
        if(circle.isDuplicated) {
          circle.position.x = mouse.x;
          circle.position.y = mouse.y;
          this.alpha = 0.5;
          this.dragging = true;
        }

        if(timelineTop.x < (circle.x + gap) && timelineTop.x > (circle.x - gap)) {
          if (isRec == false) {
            samples[i].play();
            circle.bounce();                                    
          }
        }
      }

      renderer.render(stage);
  }

  function createCircle(x, y, tint) {
    var circle = new PIXI.Sprite(texture);
    
    circle.anchor.x = 0.5;
    circle.anchor.y = 0.5;
    circle.position.x = x;
    circle.position.y = y;

    circle.scale.x = 0.1;
    circle.scale.y = 0.1;

    circle.scaleDx = 1;
    circle.scaleDy = 1;

    circle.interactive = true;
    circle.buttonMode = true;

    circle.tint = tint;
    
    circle.isDuplicated = false;
    
    circle.isInside = function(x, y) {
      var b = false;
      if (x < (circle.x + gap) && x > (circle.x - gap) && y < (circle.y + gap) && y > (circle.y - gap)) {
        b = true;
      }  
      return b;
    }

    circle.bounce = function() {
      this.scaleDx = 1.5;
      this.scaleDy = 1.5;      
    }    

    circle.deBounce = function() {
      this.scaleDx = 1;
      this.scaleDy = 1;      
    }    

    circle.mousedown = circle.touchstart = function(data)
    {
      this.data = data;
      this.alpha = 0.5;
      this.dragging = true;
    };

    circle.mouseup = circle.mouseupoutside = circle.touchend = circle.touchendoutside = function(data)
    {
      canRec = true;
      isRec = false;
      this.alpha = 1
      this.dragging = false;
      // set the interaction data to null
      this.data = null;
    };
        
    circle.mousemove = circle.touchmove = function(data)
    {
      if(this.dragging)
      {
        // need to get parent coords..
        var newPosition = this.data.getLocalPosition(this.parent);
        this.position.x = newPosition.x;
        this.position.y = newPosition.y;
      }
    }
    
    return circle;
  }
  
  function pushCircle(circle) {
    stage.addChild(circle);
    circles.push(circle);
  }

  function setSpeed(val) {
    speed = val;
    console.log(speed);
  }

  function startUserMedia(stream) {
    var input = audio_context.createMediaStreamSource(stream);
    console.log('Media stream created.');

    // Uncomment if you want the audio to feedback directly
    //input.connect(audio_context.destination);
    console.log('Input connected to audio context destination.');
    
    recorder = new Recorder(input);
    console.log('Recorder initialised.');
  }

  function startRecording() {    
    recorder && recorder.record();            
  }

  function stopRecording() {
    recorder && recorder.stop();        
    createDownloadLink();    
    recorder.clear();
  }


  function playBuffer() {
    recorder && recorder.getBuffer(function( buffers ) {
        var newSource = audio_context.createBufferSource();
        var newBuffer = audio_context.createBuffer( 2, buffers[0].length, audio_context.sampleRate );
        newBuffer.getChannelData(0).set(buffers[0]);
        newBuffer.getChannelData(1).set(buffers[1]);
        newSource.buffer = newBuffer;

        newSource.connect( audio_context.destination );
        newSource.start(0);        
      });
    }

  function createDownloadLink() {
    recorder && recorder.exportWAV(function(blob) {
      var url = URL.createObjectURL(blob);
      console.log(url);
      var li = document.createElement('li');
      var au = document.createElement('audio');
      var hf = document.createElement('a');
      
      au.controls = false;
      au.src = url;
      //au.play();
      samples.push(au);      
      //recordingslist.appendChild(li);
    });
  }

  window.onload = function init() {
    try {
      // webkit shim
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia;
      window.URL = window.URL || window.webkitURL;
      
      audio_context = new AudioContext;
      console.log('Audio context set up.');
      console.log('navigator.getUserMedia ' + (navigator.getUserMedia ? 'available.' : 'not present!'));
    } catch (e) {
      alert('No web audio support in this browser!');
    }
    
    navigator.getUserMedia({audio: true}, startUserMedia, function(e) {
      console.log('No live audio input: ' + e);
    });
  };
  </script>  
</body>
</html>
