<!DOCTYPE html>

<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Voop</title>  
</head>
<body>

  <script src="recorder.js"></script>
  <script src="pixi.js"></script>

  <script>  

  var audio_context;
  var recorder;
  var samples = [];  
  var circles = [];  
  var gap = 30;
  var canRec = true;
  var isRec = false;

  window.onmousedown = function(event) {   

          isRec = false;


          //check that is not dragging a circle
          for (var i=0; i < circles.length; i++) {
            var circle = circles[i];
            if(event.x < (circle.x + gap) && event.x > (circle.x - gap) && event.y < (circle.y + gap) && event.y > (circle.y - gap)) {
              canRec = false;              
            }
          }          

          if(canRec) {  
            //stop playback while recording
            for (var i=0; i < samples.length; i++) {    
              samples[i].pause();
              samples[i].currentTime = 0;
            }                
            isRec = true;    

            //200 is to avoid overlap of samples, as the stop is not immediate
            setTimeout(function() {startRecording()}, 200);                          
          }

          console.log("press");
  }

  window.onmouseup = function(event) {
          if (isRec) {
            console.log("isrec: " + isRec);
            stopRecording();
            createCircle(event.x, event.y);
          }
          isRec = false;
          console.log("release");          
  }


  var stage = new PIXI.Stage(0x66FF99);
  var renderer = new PIXI.WebGLRenderer(500, 600);//autoDetectRenderer(400, 300);
  
  document.body.appendChild(renderer.view);

  requestAnimFrame( animate );

  var texture = PIXI.Texture.fromImage("circle.png");  

  var timelineTxt = PIXI.Texture.fromImage("timeline.png");
  var timelineTop = new PIXI.Sprite(timelineTxt);
  
  timelineTop.position.x = 0;
  timelineTop.position.y = 30;
  
  stage.addChild(timelineTop);

  function animate() {
      requestAnimFrame( animate );   

      timelineTop.x += 3;

      if(timelineTop.x > renderer.width) {
        timelineTop.x = 0;
      }

      for (var i=0; i < circles.length; i++) {
        var circle = circles[i];
        if(timelineTop.x < (circle.x + gap) && timelineTop.x > (circle.x - gap)) {
          if (isRec == false) {
            samples[i].play();
          }
        }
      }

      renderer.render(stage);
  }

  function createCircle(x,y) {
    var circle = new PIXI.Sprite(texture);
    
    circle.anchor.x = 0.5;
    circle.anchor.y = 0.5;
    circle.position.x = x;
    circle.position.y = y;

    circle.interactive = true;
    circle.buttonMode = true;

    circle.mousedown = circle.touchstart = function(data)
    {

      this.data = data;
      this.alpha = 0.5;
      this.dragging = true;
    };

    circle.mouseup = circle.mouseupoutside = circle.touchend = circle.touchendoutside = function(data)
    {
      canRec = true;
      this.alpha = 1
      this.dragging = false;
      // set the interaction data to null
      this.data = null;
    };
        
    circle.mousemove = circle.touchmove = function(data)
    {
      if(this.dragging)
      {
        // need to get parent coords..
        var newPosition = this.data.getLocalPosition(this.parent);
        this.position.x = newPosition.x;
        this.position.y = newPosition.y;
      }
    }

    stage.addChild(circle);
    circles.push(circle);
  }

  function startUserMedia(stream) {
    var input = audio_context.createMediaStreamSource(stream);
    console.log('Media stream created.');

    // Uncomment if you want the audio to feedback directly
    //input.connect(audio_context.destination);
    console.log('Input connected to audio context destination.');
    
    recorder = new Recorder(input);
    console.log('Recorder initialised.');
  }

  function startRecording() {    
    recorder && recorder.record();            
  }

  function stopRecording() {
    recorder && recorder.stop();        
    createDownloadLink();    
    recorder.clear();
  }


  function playBuffer() {
    recorder && recorder.getBuffer(function( buffers ) {
        var newSource = audio_context.createBufferSource();
        var newBuffer = audio_context.createBuffer( 2, buffers[0].length, audio_context.sampleRate );
        newBuffer.getChannelData(0).set(buffers[0]);
        newBuffer.getChannelData(1).set(buffers[1]);
        newSource.buffer = newBuffer;

        newSource.connect( audio_context.destination );
        newSource.start(0);        
      });
    }

  function createDownloadLink() {
    recorder && recorder.exportWAV(function(blob) {
      var url = URL.createObjectURL(blob);
      console.log(url);
      var li = document.createElement('li');
      var au = document.createElement('audio');
      var hf = document.createElement('a');
      
      au.controls = false;
      au.src = url;
      //au.play();
      samples.push(au);      
      //recordingslist.appendChild(li);
    });
  }

  window.onload = function init() {
    try {
      // webkit shim
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia;
      window.URL = window.URL || window.webkitURL;
      
      audio_context = new AudioContext;
      console.log('Audio context set up.');
      console.log('navigator.getUserMedia ' + (navigator.getUserMedia ? 'available.' : 'not present!'));
    } catch (e) {
      alert('No web audio support in this browser!');
    }
    
    navigator.getUserMedia({audio: true}, startUserMedia, function(e) {
      console.log('No live audio input: ' + e);
    });
  };
  </script>  
</body>
</html>
